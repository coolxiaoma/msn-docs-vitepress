import{_ as a,c as i,o as e,ag as p}from"./chunks/framework.B4sg4S7y.js";const k=JSON.parse('{"title":"五层网络模型","description":"","frontmatter":{},"headers":[],"relativePath":"pages/网络/知识.md","filePath":"pages/网络/知识.md"}'),n={name:"pages/网络/知识.md"};function t(l,s,o,h,c,d){return e(),i("div",null,[...s[0]||(s[0]=[p(`<h1 id="五层网络模型" tabindex="-1">五层网络模型 <a class="header-anchor" href="#五层网络模型" aria-label="Permalink to &quot;五层网络模型&quot;">​</a></h1><p>分层的意义 当遇到一个复杂问题的时候，可以使用分层的思想把问题简单化</p><p>比如，你有半杯82年的可乐，想分享给你的朋友王富贵，但你们已经10年没有联系了。要完成这件事，你可能要考虑：</p><p>我用什么装可乐？</p><p>可能的方案：塑料瓶、玻璃瓶、煤气罐</p><p>怎么保证可乐始终处于低温？</p><p>可能的方案：保温杯、小冰箱、冰盒</p><p>如何保证可乐不被运输的人偷喝？</p><p>可能的方案：封条、在上面写「毒药」</p><p>如何获取王富贵的地址？</p><p>可能的方案：报案失踪、联系私人侦探、联系物流公司的朋友</p><p>如何运输？</p><h2 id="分层的意义" tabindex="-1">分层的意义 <a class="header-anchor" href="#分层的意义" aria-label="Permalink to &quot;分层的意义&quot;">​</a></h2><p>当遇到一个复杂问题的时候，可以使用分层的思想把问题简单化</p><p>比如，你有半杯82年的可乐，想分享给你的朋友王富贵，但你们已经10年没有联系了。要完成这件事，你可能要考虑：</p><ul><li><p>我用什么装可乐？</p><p>可能的方案：塑料瓶、玻璃瓶、煤气罐</p></li><li><p>怎么保证可乐始终处于低温？</p><p>可能的方案：保温杯、小冰箱、冰盒</p></li><li><p>如何保证可乐不被运输的人偷喝？</p><p>可能的方案：封条、在上面写「毒药」</p></li><li><p>如何获取王富贵的地址？</p><p>可能的方案：报案失踪、联系私人侦探、联系物流公司的朋友</p></li><li><p>如何运输？</p><p>可能的方案：自行车、汽车、火车、高铁、飞机、火箭</p></li></ul><p>这就形成了一个分层结构</p><img src="http://mdrs.yuanjin.tech/img/20210927145456.png" alt="image-20210927145456656" style="zoom:50%;"><p>从常理出发，我们可以得出以下结论：</p><ul><li>每层相对独立，只需解决自己的问题</li><li>每层无须考虑上层的交付，仅需把自己的结果交给下层即可</li><li>每层有多种方案可供选择，选择不同的方案不会对上下层造成影响</li><li>每一层会在上一层的基础上增加一些额外信息</li></ul><h2 id="五层网络模型-1" tabindex="-1">五层网络模型 <a class="header-anchor" href="#五层网络模型-1" aria-label="Permalink to &quot;五层网络模型&quot;">​</a></h2><p><img src="http://mdrs.yuanjin.tech/img/20211008163417.png" alt="image-20211008163417521"></p><h2 id="数据的封装和解封装" tabindex="-1">数据的封装和解封装 <a class="header-anchor" href="#数据的封装和解封装" aria-label="Permalink to &quot;数据的封装和解封装&quot;">​</a></h2><p><img src="http://mdrs.yuanjin.tech/img/20211008163458.png" alt="image-20211008163458168"></p><h2 id="四层、五层、七层" tabindex="-1">四层、五层、七层 <a class="header-anchor" href="#四层、五层、七层" aria-label="Permalink to &quot;四层、五层、七层&quot;">​</a></h2><p><img src="http://mdrs.yuanjin.tech/img/20211008164017.png" alt="image-20211008164017299"></p><h2 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><p>说说网络的五层模型（寺库）</p><blockquote><p>参考答案：</p><p>从上到下分别为：应用层、传输层、网络层、数据链路层、物理层。在发送消息时，消息从上到下进行打包，每一层会在上一层基础上加包，而接受消息时，从下到上进行解包，最终得到原始信息。</p><p>其中：</p><p>应用层主要面向互联网中的应用场景，比如网页、邮件、文件中心等等，它的代表协议有 http、smtp、pop3、ftp、DNS 等等</p><p>传输层主要面向传输过程，比如 TCP 协议是为了保证可靠的传输，而 UDP 协议则是一种无连接的广播，它们提供了不同的传输方式</p><p>网络层主要解决如何定位目标以及如何寻找最优路径的问题，比如 IP 等等</p><p>数据链路层的作用是将数据在一个子网（广播域）内有效传输，MAC地址、交换机都是属于该层的</p><p>物理层是要解决二进制数据到信号之间的互转问题，集线器、双绞线、同轴电缆等都是属于盖层的设备</p></blockquote><h2 id="请求方法的本质" tabindex="-1">请求方法的本质 <a class="header-anchor" href="#请求方法的本质" aria-label="Permalink to &quot;请求方法的本质&quot;">​</a></h2><p><strong>请求方法是请求行中的第一个单词，它向服务器描述了客户端发出请求的动作类型。在 HTTP 协议中，不同的请求方法只是包含了不同的语义，但服务器和浏览器的一些约定俗成的行为造成了它们具体的区别</strong></p><p><img src="http://mdrs.yuanjin.tech/img/20210914102745.png" alt="image-20210914102745190"></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://www.baidu.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;heiheihei&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 告诉百度，我这次请求是来嘿嘿嘿的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>上面的请求中，我们使用了自定义方法<code>heiheihei</code>。虽然百度服务器无法理解这样的请求是在干什么，但这样的请求也是可以正常发送到百度服务器的。</p><p>在实践中，客户端和服务器慢慢的形成了一个共识，约定俗成的规定了一些常见的请求方法：</p><ul><li>GET，表示向服务器获取资源。业务数据在请求行中，无须请求体</li><li>POST，表示向服务器提交信息，通常用于产生新的数据，比如注册。业务数据在请求体中</li><li>PUT，表示希望修改服务器的数据，通常用于修改。业务数据在请求体中</li><li>DELETE，表示希望删除服务器的数据。业务数据在请求行中，无须请求体。</li><li>OPTIONS，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交</li><li>TRACE，回显服务器收到的请求，主要用于测试和诊断</li><li>CONNECT，用于建立连接管道，通常在代理场景中使用，网页中很少用到</li></ul><h2 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别&quot;">​</a></h2><p><strong>由于浏览器和服务器约定俗称的规则</strong>，造成了 GET 和 POST 请求在 web 中的区别：</p><ol><li>浏览器在发送 GET 请求时，不会附带请求体</li><li>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</li><li>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</li><li>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</li><li>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</li><li>GET 请求的地址可以被保存为浏览器书签，POST 不可以</li></ol><h2 id="面试题-1" tabindex="-1">面试题 <a class="header-anchor" href="#面试题-1" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><ol><li>http 常见请求方法有哪些？</li></ol><blockquote><p>参考答案：</p><ul><li>GET，表示向服务器获取资源</li><li>POST，表示向服务器提交信息，通常用于产生新的数据，比如注册</li><li>PUT，表示希望修改服务器的数据，通常用于修改</li><li>DELETE，表示希望删除服务器的数据</li><li>OPTIONS，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交</li><li>TRACE，回显服务器收到的请求，主要用于测试和诊断</li><li>CONNECT，用于建立连接管道，通常在代理场景中使用，网页中很少用到</li></ul></blockquote><ol start="2"><li>GET 和 POST 的区别（流利说）</li></ol><blockquote><p>参考答案：</p><p>从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。</p><p>之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。</p><p>受浏览器的影响，在实际开发中，GET 和 POST 有以下区别：</p><ol><li>浏览器在发送 GET 请求时，不会附带请求体</li><li>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</li><li>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</li><li>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</li><li>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</li><li>GET 请求的地址可以被保存为浏览器书签，POST 不可以</li></ol></blockquote><h1 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h1><h2 id="一个不大不小的问题" tabindex="-1">一个不大不小的问题 <a class="header-anchor" href="#一个不大不小的问题" aria-label="Permalink to &quot;一个不大不小的问题&quot;">​</a></h2><p>假设服务器有一个接口，通过请求这个接口，可以添加一个管理员</p><p>但是，不是任何人都有权力做这种操作的</p><p>那么服务器如何知道请求接口的人是有权力的呢？</p><p>答案是：只有登录过的管理员才能做这种操作</p><p>可问题是，客户端和服务器的传输使用的是http协议，http协议是无状态的，什么叫无状态，就是<strong>服务器不知道这一次请求的人，跟之前登录请求成功的人是不是同一个人</strong></p><p><img src="http://mdrs.yuanjin.tech/img/image-20200417161014030.png" alt="img"></p><p><img src="http://mdrs.yuanjin.tech/img/image-20200417161244373.png" alt="img"></p><p>由于http协议的无状态，服务器<strong>忘记</strong>了之前的所有请求，它无法确定这一次请求的客户端，就是之前登录成功的那个客户端。</p><blockquote><p>你可以把服务器想象成有着严重脸盲症的东哥，他没有办法分清楚跟他说话的人之前做过什么</p></blockquote><p>于是，服务器想了一个办法</p><p>它按照下面的流程来认证客户端的身份</p><ol><li>客户端登录成功后，服务器会给客户端一个出入证</li><li>后续客户端的每次请求，都必须要附带这个出入证</li></ol><p><img src="http://mdrs.yuanjin.tech/img/image-20200417161950450.png" alt="img"></p><p>服务器发扬了认证不认人的优良传统，就可以很轻松的识别身份了。</p><p>但是，用户不可能只在一个网站登录，于是客户端会收到来自各个网站的出入证，因此，就要求客户端要有一个类似于卡包的东西，能够具备下面的功能：</p><ol><li><strong>能够存放多个出入证</strong>。这些出入证来自不同的网站，也可能是一个网站有多个出入证，分别用于出入不同的地方</li><li><strong>能够自动出示出入证</strong>。客户端在访问不同的网站时，能够自动的把对应的出入证附带请求发送出去。</li><li><strong>正确的出示出入证</strong>。客户端不能将肯德基的出入证发送给麦当劳。</li><li><strong>管理出入证的有效期</strong>。客户端要能够自动的发现那些已经过期的出入证，并把它从卡包内移除。</li></ol><p>能够满足上面所有要求的，就是cookie</p><p>cookie类似于一个卡包，专门用于存放各种出入证，并有着一套机制来自动管理这些证件。</p><p>卡包内的每一张卡片，称之为<strong>一个cookie</strong>。</p><h2 id="cookie的组成" tabindex="-1">cookie的组成 <a class="header-anchor" href="#cookie的组成" aria-label="Permalink to &quot;cookie的组成&quot;">​</a></h2><p>cookie是浏览器中特有的一个概念，它就像浏览器的专属卡包，管理着各个网站的身份信息。</p><p>每个cookie就相当于是属于某个网站的一个卡片，它记录了下面的信息：</p><ul><li>key：键，比如「身份编号」</li><li>value：值，比如袁小进的身份编号「14563D1550F2F76D69ECBF4DD54ABC95」，这有点像卡片的条形码，当然，它可以是任何信息</li><li>domain：域，表达这个cookie是属于哪个网站的，比如<code>yuanjin.tech</code>，表示这个cookie是属于<code>yuanjin.tech</code>这个网站的</li><li>path：路径，表达这个cookie是属于该网站的哪个基路径的，就好比是同一家公司不同部门会颁发不同的出入证。比如<code>/news</code>，表示这个cookie属于<code>/news</code>这个路径的。（后续详细解释）</li><li>secure：是否使用安全传输（后续详细解释）</li><li>expire：过期时间，表示该cookie在什么时候过期</li></ul><p>当浏览器向服务器发送一个请求的时候，它会瞄一眼自己的卡包，看看哪些卡片适合附带捎给服务器</p><p>如果一个cookie<strong>同时满足</strong>以下条件，则这个cookie会被附带到请求中</p><ul><li>cookie没有过期</li><li>cookie中的域和这次请求的域是匹配的 <ul><li>比如cookie中的域是<code>yuanjin.tech</code>，则可以匹配的请求域是<code>yuanjin.tech</code>、<code>www.yuanjin.tech</code>、<code>blogs.yuanjin.tech</code>等等</li><li>比如cookie中的域是<code>www.yuanjin.tech</code>，则只能匹配<code>www.yuanjin.tech</code>这样的请求域</li><li>cookie是不在乎端口的，只要域匹配即可</li></ul></li><li>cookie中的path和这次请求的path是匹配的 <ul><li>比如cookie中的path是<code>/news</code>，则可以匹配的请求路径可以是<code>/news</code>、<code>/news/detail</code>、<code>/news/a/b/c</code>等等，但不能匹配<code>/blogs</code></li><li>如果cookie的path是<code>/</code>，可以想象，能够匹配所有的路径</li></ul></li><li>验证cookie的安全传输 <ul><li>如果cookie的secure属性是true，则请求协议必须是<code>https</code>，否则不会发送该cookie</li><li>如果cookie的secure属性是false，则请求协议可以是<code>http</code>，也可以是<code>https</code></li></ul></li></ul><p>如果一个cookie满足了上述的所有条件，则浏览器会把它自动加入到这次请求中</p><p>具体加入的方式是，<strong>浏览器会将符合条件的cookie，自动放置到请求头中</strong>，例如，当我在浏览器中访问百度的时候，它在请求头中附带了下面的cookie：</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200417170328584.png" alt="img"></p><p>看到打马赛克的地方了吗？这部分就是通过请求头<code>cookie</code>发送到服务器的，它的格式是<code>键=值; 键=值; 键=值; ...</code>，每一个键值对就是一个符合条件的cookie。</p><p>**cookie中包含了重要的身份信息，永远不要把你的cookie泄露给别人！！！**否则，他人就拿到了你的证件，有了证件，就具备了为所欲为的可能性。</p><h2 id="如何设置cookie" tabindex="-1">如何设置cookie <a class="header-anchor" href="#如何设置cookie" aria-label="Permalink to &quot;如何设置cookie&quot;">​</a></h2><p>由于cookie是保存在浏览器端的，同时，很多证件又是服务器颁发的</p><p>所以，cookie的设置有两种模式：</p><ul><li>服务器响应：这种模式是非常普遍的，当服务器决定给客户端颁发一个证件时，它会在响应的消息中包含cookie，浏览器会自动的把cookie保存到卡包中</li><li>客户端自行设置：这种模式少见一些，不过也有可能会发生，比如用户关闭了某个广告，并选择了「以后不要再弹出」，此时就可以把这种小信息直接通过浏览器的JS代码保存到cookie中。后续请求服务器时，服务器会看到客户端不想要再次弹出广告的cookie，于是就不会再发送广告过来了。</li></ul><h2 id="服务器端设置cookie" tabindex="-1">服务器端设置cookie <a class="header-anchor" href="#服务器端设置cookie" aria-label="Permalink to &quot;服务器端设置cookie&quot;">​</a></h2><p>服务器可以通过设置响应头，来告诉浏览器应该如何设置cookie</p><p>响应头按照下面的格式设置：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">set-cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cookie1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">set-cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cookie2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">set-cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cookie3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">...</span></span></code></pre></div><p>通过这种模式，就可以在一次响应中设置多个cookie了，具体设置多少个cookie，设置什么cookie，根据你的需要自行处理</p><p>其中，每个cookie的格式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>键=值; path=?; domain=?; expire=?; max-age=?; secure; httponly</span></span></code></pre></div><p>每个cookie除了键值对是必须要设置的，其他的属性都是可选的，并且顺序不限</p><p>当这样的响应头到达客户端后，<strong>浏览器会自动的将cookie保存到卡包中，如果卡包中已经存在一模一样的卡片（其他path、domain相同），则会自动的覆盖之前的设置</strong>。</p><p>下面，依次说明每个属性值：</p><ul><li><p><strong>path</strong>：设置cookie的路径。如果不设置，浏览器会将其自动设置为当前请求的路径。比如，浏览器请求的地址是<code>/login</code>，服务器响应了一个<code>set-cookie: a=1</code>，浏览器会将该cookie的path设置为请求的路径<code>/login</code></p></li><li><p><strong>domain</strong>：设置cookie的域。如果不设置，浏览器会自动将其设置为当前的请求域，比如，浏览器请求的地址是</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>http://www.yuanjin.tech</span></span></code></pre></div><p>，服务器响应了一个</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>set-cookie: a=1</span></span></code></pre></div><p>，浏览器会将该cookie的domain设置为请求的域</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>www.yuanjin.tech</span></span></code></pre></div><ul><li>这里值得注意的是，如果服务器响应了一个无效的域，浏览器是不认的</li><li>什么是无效的域？就是响应的域连根域都不一样。比如，浏览器请求的域是<code>yuanjin.tech</code>，服务器响应的cookie是<code>set-cookie: a=1; domain=baidu.com</code>，这样的域浏览器是不认的。</li><li>如果浏览器连这样的情况都允许，就意味着张三的服务器，有权利给用户一个cookie，用于访问李四的服务器，这会造成很多安全性的问题</li></ul></li><li><p><strong>expire</strong>：设置cookie的过期时间。这里必须是一个有效的GMT时间，即格林威治标准时间字符串，比如<code>Fri, 17 Apr 2020 09:35:59 GMT</code>，表示格林威治时间的<code>2020-04-17 09:35:59</code>，即北京时间的<code>2020-04-17 17:35:59</code>。当客户端的时间达到这个时间点后，会自动销毁该cookie。</p></li><li><p><strong>max-age</strong>：设置cookie的相对有效期。expire和max-age通常仅设置一个即可。比如设置<code>max-age</code>为<code>1000</code>，浏览器在添加cookie时，会自动设置它的<code>expire</code>为当前时间加上1000秒，作为过期时间。</p><ul><li>如果不设置expire，又没有设置max-age，则表示会话结束后过期。</li><li>对于大部分浏览器而言，关闭所有浏览器窗口意味着会话结束。</li></ul></li><li><p><strong>secure</strong>：设置cookie是否是安全连接。如果设置了该值，则表示该cookie后续只能随着<code>https</code>请求发送。如果不设置，则表示该cookie会随着所有请求发送。</p></li><li><p><strong>httponly</strong>：设置cookie是否仅能用于传输。如果设置了该值，表示该cookie仅能用于传输，而不允许在客户端通过JS获取，这对防止跨站脚本攻击（XSS）会很有用。</p><ul><li>关于如何通过JS获取，后续会讲解</li></ul></li><li><p>关于什么是XSS，不在本文讨论范围</p></li></ul><p>下面来一个例子，客户端通过<code>post</code>请求服务器<code>http://yuanjin.tech/login</code>，并在消息体中给予了账号和密码，服务器验证登录成功后，在响应头中加入了以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>set-cookie: token=123456; path=/; max-age=3600; httponly</span></span></code></pre></div><p>当该响应到达浏览器后，浏览器会创建下面的cookie：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">token</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123456</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">domain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">yuanjin.tech</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">expire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2020-04-17 18:55:00</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #假设当前时间是2020-04-17 17:55:00</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">secure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  #任何请求都可以附带这个cookie，只要满足其他要求</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">httponly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #不允许JS获取该cookie</span></span></code></pre></div><p>于是，随着浏览器后续对服务器的请求，只要满足要求，这个cookie就会被附带到请求头中传给服务器：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">token=123456; 其他cookie...</span></span></code></pre></div><p>现在，还剩下最后一个问题，就是如何删除浏览器的一个cookie呢？</p><p>如果要删除浏览器的cookie，只需要让服务器响应一个同样的域、同样的路径、同样的key，只是时间过期的cookie即可</p><p><strong>所以，删除cookie其实就是修改cookie</strong></p><p>下面的响应会让浏览器删除<code>token</code></p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">set-cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">token=; domain=yuanjin.tech; path=/; max-age=-1</span></span></code></pre></div><p>浏览器按照要求修改了cookie后，会发现cookie已经过期，于是自然就会删除了。</p><blockquote><p>无论是修改还是删除，都要注意cookie的域和路径，因为完全可能存在域或路径不同，但key相同的cookie</p><p>因此无法仅通过key确定是哪一个cookie</p></blockquote><h2 id="客户端设置cookie" tabindex="-1">客户端设置cookie <a class="header-anchor" href="#客户端设置cookie" aria-label="Permalink to &quot;客户端设置cookie&quot;">​</a></h2><p>既然cookie是存放在浏览器端的，所以浏览器向JS公开了接口，让其可以设置cookie</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;键=值; path=?; domain=?; expire=?; max-age=?; secure&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>可以看出，在客户端设置cookie，和服务器设置cookie的格式一样，只是有下面的不同</p><ul><li>没有httponly。因为httponly本来就是为了限制在客户端访问的，既然你是在客户端配置，自然失去了限制的意义。</li><li>path的默认值。在服务器端设置cookie时，如果没有写path，使用的是请求的path。而在客户端设置cookie时，也许根本没有请求发生。因此，path在客户端设置时的默认值是当前网页的path</li><li>domain的默认值。和path同理，客户端设置时的默认值是当前网页的domain</li><li>其他：一样</li><li>删除cookie：和服务器也一样，修改cookie的过期时间即可</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>以上，就是cookie原理部分的内容。</p><p>如果把它用于登录场景，就是如下的流程：</p><p><strong>登录请求</strong></p><ol><li>浏览器发送请求到服务器，附带账号密码</li><li>服务器验证账号密码是否正确，如果不正确，响应错误，如果正确，在响应头中设置cookie，附带登录认证信息（至于登录认证信息是设么样的，如何设计，要考虑哪些问题，就是另一个话题了，可以百度 jwt）</li><li>客户端收到cookie，浏览器自动记录下来</li></ol><p><strong>后续请求</strong></p><ol><li>浏览器发送请求到服务器，希望添加一个管理员，并将cookie自动附带到请求中</li><li>服务器先获取cookie，验证cookie中的信息是否正确，如果不正确，不予以操作，如果正确，完成正常的业务流程</li></ol><h2 id="cookie-sessionstorage-localstorage-的区别" tabindex="-1">cookie/sessionStorage/localStorage 的区别 <a class="header-anchor" href="#cookie-sessionstorage-localstorage-的区别" aria-label="Permalink to &quot;cookie/sessionStorage/localStorage 的区别&quot;">​</a></h2><h3 id="面试题-2" tabindex="-1">面试题 <a class="header-anchor" href="#面试题-2" aria-label="Permalink to &quot;面试题&quot;">​</a></h3><p>cookie/sessionStorage/localStorage 的区别</p><blockquote><p>参考答案：</p><p>cookie、sessionStorage、localStorage 都是保存本地数据的方式</p><p>其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现<code>set-cookie</code>字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式</p><p>HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。 cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量不超过 4KB，而 sessionStorage 和 localStorage 则拥有更大的空间，多数浏览器一般要求不超过 5MB~10MB cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联</p></blockquote><h1 id="jwt" tabindex="-1">JWT <a class="header-anchor" href="#jwt" aria-label="Permalink to &quot;JWT&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>回顾登录的流程：</p><img src="http://mdrs.yuanjin.tech/img/image-20200417161950450.png" alt="img" align="left"><p>接下来的问题是：这个出入证（令牌）里面到底存啥？</p><p>一种比较简单的办法就是直接存储用户信息的JSON串，这会造成下面的几个问题：</p><ul><li>非浏览器环境，如何在令牌中记录过期时间</li><li>如何防止令牌被伪造</li></ul><p>JWT就是为了解决这些问题出现的。</p><p>JWT全称<code>Json Web Token</code>，本质就是一个字符串</p><p>它要解决的问题，就是在互联网环境中，提供<strong>统一的、安全的</strong>令牌格式</p><p>因此，jwt只是一个令牌格式而已，你可以把它存储到cookie，也可以存储到localstorage，没有任何限制！</p><p>同样的，对于传输，你可以使用任何传输方式来传输jwt，一般来说，我们会使用消息头来传输它</p><p>比如，当登录成功后，服务器可以给客户端响应一个jwt：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>set-cookie:token=jwt令牌</span></span>
<span class="line"><span>authentication:jwt令牌</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>{..., token:jwt令牌}</span></span></code></pre></div><p>可以看到，jwt令牌可以出现在响应的任何一个地方，客户端和服务器自行约定即可。</p><blockquote><p>当然，它也可以出现在响应的多个地方，比如为了充分利用浏览器的cookie，同时为了照顾其他设备，也可以让jwt出现在<code>set-cookie</code>和<code>authorization或body</code>中，尽管这会增加额外的传输量。</p></blockquote><p>当客户端拿到令牌后，它要做的只有一件事：存储它。</p><p>你可以存储到任何位置，比如手机文件、PC文件、localstorage、cookie</p><p>当后续请求发生时，你只需要将它作为请求的一部分发送到服务器即可。</p><p>虽然jwt没有明确要求应该如何附带到请求中，但通常我们会使用如下的格式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GET /api/resources HTTP/1.1</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>authorization: bearer jwt令牌</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>这样一来，服务器就能够收到这个令牌了，通过对令牌的验证，即可知道该令牌是否有效。</p><p>它们的完整交互流程是非常简单清晰的</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200422172837190.png" alt="image-20200422172837190"></p><h2 id="令牌的组成" tabindex="-1">令牌的组成 <a class="header-anchor" href="#令牌的组成" aria-label="Permalink to &quot;令牌的组成&quot;">​</a></h2><p>为了保证令牌的安全性，jwt令牌由三个部分组成，分别是：</p><ol><li>header：令牌头部，记录了整个令牌的类型和签名算法</li><li>payload：令牌负荷，记录了保存的主体信息，比如你要保存的用户信息就可以放到这里</li><li>signature：令牌签名，按照头部固定的签名算法对整个令牌进行签名，该签名的作用是：保证令牌不被伪造和篡改</li></ol><p>它们组合而成的完整格式是：<code>header.payload.signature</code></p><p>比如，一个完整的jwt令牌如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></span></code></pre></div><p>它各个部分的值分别是：</p><ul><li><code>header：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></li><li><code>payload：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code></li><li><code>signature: BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</code></li></ul><p>下面分别对每个部分进行说明</p><h3 id="header" tabindex="-1">header <a class="header-anchor" href="#header" aria-label="Permalink to &quot;header&quot;">​</a></h3><p>它是令牌头部，记录了整个令牌的类型和签名算法</p><p>它的格式是一个<code>json</code>对象，如下：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;alg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;HS256&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;typ&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;JWT&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该对象记录了：</p><ul><li>alg：signature部分使用的签名算法，通常可以取两个值 <ul><li>HS256：一种对称加密算法，使用同一个秘钥对signature加密解密</li><li>RS256：一种非对称加密算法，使用私钥签名，公钥验证</li></ul></li><li>typ：整个令牌的类型，固定写<code>JWT</code>即可</li></ul><p>设置好了<code>header</code>之后，就可以生成<code>header</code>部分了</p><p>具体的生成方式及其简单，就是把<code>header</code>部分使用<code>base64 url</code>编码即可</p><blockquote><p><code>base64 url</code>不是一个加密算法，而是一种编码方式，它是在<code>base64</code>算法的基础上对<code>+</code>、<code>=</code>、<code>/</code>三个字符做出特殊处理的算法</p><p>而<code>base64</code>是使用64个可打印字符来表示一个二进制数据，具体的做法参考<a href="https://baike.baidu.com/item/base64/8545775?fr=aladdin" target="_blank" rel="noreferrer">百度百科</a></p></blockquote><p>浏览器提供了<code>btoa</code>函数，可以完成这个操作：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">btoa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;alg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;HS256&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;typ&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;JWT&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 得到字符串：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span></span></code></pre></div><p>同样的，浏览器也提供了<code>atob</code>函数，可以对其进行解码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">atob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 得到字符串：{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</span></span></code></pre></div><blockquote><p>nodejs中没有提供这两个函数，可以安装第三方库<code>atob</code>和<code>bota</code>搞定</p><p>或者，手动搞定</p></blockquote><h3 id="payload" tabindex="-1">payload <a class="header-anchor" href="#payload" aria-label="Permalink to &quot;payload&quot;">​</a></h3><p>这部分是jwt的主体信息，它仍然是一个JSON对象，它可以包含以下内容：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;ss&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;发行者&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;iat&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;发布时间&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;exp&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;到期时间&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;sub&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;主题&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;aud&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;听众&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;nbf&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;在此之前不可用&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;jti&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;JWT ID&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上属性可以全写，也可以一个都不写，它只是一个规范，就算写了，也需要你在将来验证这个jwt令牌时手动处理才能发挥作用</p><p>上述属性表达的含义分别是：</p><ul><li>ss：发行该jwt的是谁，可以写公司名字，也可以写服务名称</li><li>iat：该jwt的发放时间，通常写当前时间的时间戳</li><li>exp：该jwt的到期时间，通常写时间戳</li><li>sub：该jwt是用于干嘛的</li><li>aud：该jwt是发放给哪个终端的，可以是终端类型，也可以是用户名称，随意一点</li><li>nbf：一个时间点，在该时间点到达之前，这个令牌是不可用的</li><li>jti：jwt的唯一编号，设置此项的目的，主要是为了防止重放攻击（重放攻击是在某些场景下，用户使用之前的令牌发送到服务器，被服务器正确的识别，从而导致不可预期的行为发生）</li></ul><p>可是到现在，看了半天，没有出现我想要写入的数据啊😂</p><p>当用户登陆成功之后，我可能需要把用户的一些信息写入到jwt令牌中，比如用户id、账号等等（密码就算了😳）</p><p>其实很简单，payload这一部分只是一个json对象而已，你可以向对象中加入任何想要加入的信息</p><p>比如，下面的json对象仍然是一个有效的payload</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;iat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1587548215</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>foo: bar</code>是我们自定义的信息，<code>iat: 1587548215</code>是jwt规范中的信息</p><p>最终，payload部分和header一样，需要通过<code>base64 url</code>编码得到：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">btoa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;iat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1587548215</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 得到字符串：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</span></span></code></pre></div><h3 id="signature" tabindex="-1">signature <a class="header-anchor" href="#signature" aria-label="Permalink to &quot;signature&quot;">​</a></h3><p>这一部分是jwt的签名，正是它的存在，保证了整个jwt不被篡改</p><p>这部分的生成，是对前面两个部分的编码结果，按照头部指定的方式进行加密</p><p>比如：头部指定的加密方法是<code>HS256</code>，前面两部分的编码结果是<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code></p><p>则第三部分就是用对称加密算法<code>HS256</code>对字符串<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code>进行加密，当然你得指定一个秘钥，比如<code>shhhhh</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HS256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;shhhhh&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 得到：BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></span></code></pre></div><p>最终，将三部分组合在一起，就得到了完整的jwt</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></span></code></pre></div><p>由于签名使用的秘钥保存在服务器，这样一来，客户端就无法伪造出签名，因为它拿不到秘钥。</p><p>换句话说，之所以说无法伪造jwt，就是因为第三部分的存在。</p><p>而前面两部分并没有加密，只是一个编码结果而已，可以认为几乎是明文传输</p><blockquote><p>这不会造成太大的问题，因为既然用户登陆成功了，它当然有权力查看自己的用户信息</p><p>甚至在某些网站，用户的基本信息可以被任何人查看</p><p>你要保证的，是不要把敏感的信息存放到jwt中，比如密码</p></blockquote><p>jwt的<code>signature</code>可以保证令牌不被伪造，那如何保证令牌不被篡改呢？</p><p>比如，某个用户登陆成功了，获得了jwt，但他人为的篡改了<code>payload</code>，比如把自己的账户余额修改为原来的两倍，然后重新编码出<code>payload</code>发送到服务器，服务器如何得知这些信息被篡改过了呢？</p><p>这就要说到令牌的验证了</p><h2 id="令牌的验证" tabindex="-1">令牌的验证 <a class="header-anchor" href="#令牌的验证" aria-label="Permalink to &quot;令牌的验证&quot;">​</a></h2><p><img src="http://mdrs.yuanjin.tech/img/image-20200422172837190.png" alt="image-20200422172837190"></p><p>令牌在服务器组装完成后，会以任意的方式发送到客户端</p><p>客户端会把令牌保存起来，后续的请求会将令牌发送给服务器</p><p>而服务器需要验证令牌是否正确，如何验证呢？</p><p>首先，服务器要验证这个令牌是否被篡改过，验证方式非常简单，就是对<code>header+payload</code>用同样的秘钥和加密算法进行重新加密</p><p>然后把加密的结果和传入jwt的<code>signature</code>进行对比，如果完全相同，则表示前面两部分没有动过，就是自己颁发的，如果不同，肯定是被篡改过了。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>传入的header.传入的payload.传入的signature</span></span>
<span class="line"><span>新的signature = header中的加密算法(传入的header.传入的payload, 秘钥)</span></span>
<span class="line"><span>验证：新的signature == 传入的signature</span></span></code></pre></div><p>当令牌验证为没有被篡改后，服务器可以进行其他验证：比如是否过期、听众是否满足要求等等，这些就视情况而定了</p><p>注意：这些验证都需要服务器手动完成，没有哪个服务器会给你进行自动验证，当然，你可以借助第三方库来完成这些操作</p><h2 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>最后，总结一下jwt的特点：</p><ul><li>jwt本质上是一种令牌格式。它和终端设备无关，同样和服务器无关，甚至与如何传输无关，它只是规范了令牌的格式而已</li><li>jwt由三部分组成：header、payload、signature。主体信息在payload</li><li>jwt难以被篡改和伪造。这是因为有第三部分的签名存在。</li></ul><h2 id="面试题-3" tabindex="-1">面试题 <a class="header-anchor" href="#面试题-3" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><p>请阐述JWT的令牌格式</p><blockquote><p>参考答案：</p><p>token 分为三段，分别是 header、payload、signature</p><p>其中，header 标识签名算法和令牌类型；payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；signature 是使用特定的算法对前面两部分进行加密，得到的加密结果。</p><p>token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。</p><p>所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。</p></blockquote><h1 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h1><p>浏览器有一个重要的安全策略，称之为「同源策略」</p><p>其中，$源=协议+主机+端口$，两个源相同，称之为同源，两个源不同，称之为跨源或跨域</p><p>比如：</p><table tabindex="0"><thead><tr><th>源 1</th><th>源 2</th><th>是否同源</th></tr></thead><tbody><tr><td><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></td><td><a href="http://www.baidu.com/news" target="_blank" rel="noreferrer">http://www.baidu.com/news</a></td><td>✅</td></tr><tr><td><a href="https://www.baidu.com" target="_blank" rel="noreferrer">https://www.baidu.com</a></td><td><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></td><td>❌</td></tr><tr><td><a href="http://localhost:5000" target="_blank" rel="noreferrer">http://localhost:5000</a></td><td><a href="http://localhost:7000" target="_blank" rel="noreferrer">http://localhost:7000</a></td><td>❌</td></tr><tr><td><a href="http://localhost:5000" target="_blank" rel="noreferrer">http://localhost:5000</a></td><td><a href="http://127.0.0.1:5000" target="_blank" rel="noreferrer">http://127.0.0.1:5000</a></td><td>❌</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></td><td><a href="http://baidu.com" target="_blank" rel="noreferrer">http://baidu.com</a></td><td>❌</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制</strong></p><p><img src="http://mdrs.yuanjin.tech/img/20210916104747.png" alt="image-20210916104747296"></p><p>同源策略对 ajax 的跨域限制的最为<em>凶狠</em>，默认情况下，它不允许 ajax 访问跨域资源</p><p><img src="http://mdrs.yuanjin.tech/img/20210916105741.png" alt="image-20210916105741041"></p><p>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响</p><p>有多种方式解决跨域问题，常见的有：</p><ul><li><strong>代理</strong>，常用</li><li><strong>CORS</strong>，常用</li><li>JSONP</li></ul><p>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。</p><h1 id="跨域-代理" tabindex="-1">跨域-代理 <a class="header-anchor" href="#跨域-代理" aria-label="Permalink to &quot;跨域-代理&quot;">​</a></h1><p><strong>对于前端开发而言</strong>，大部分的跨域问题，都是通过代理解决的</p><p><strong>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</strong></p><p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理</p><p><img src="http://mdrs.yuanjin.tech/img/20210916125008.png" alt="image-20210916125008693"></p><p>在实际开发中，只需要对开发服务器稍加配置即可完成</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vue 的开发服务器代理配置</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vue.config.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  devServer: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置开发服务器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    proxy: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置代理</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;/api&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 若请求路径以 /api 开头</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://dev.taobao.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将其转发到 http://dev.taobao.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h1 id="跨域-cors" tabindex="-1">跨域-CORS <a class="header-anchor" href="#跨域-cors" aria-label="Permalink to &quot;跨域-CORS&quot;">​</a></h1><h2 id="概述-1" tabindex="-1">概述 <a class="header-anchor" href="#概述-1" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p><code>CORS</code>是基于<code>http1.1</code>的一种跨域解决方案，它的全称是<strong>C</strong>ross-<strong>O</strong>rigin <strong>R</strong>esource <strong>S</strong>haring，跨域资源共享。</p><p>它的总体思路是：<strong>如果浏览器要跨域访问服务器的资源，需要获得服务器的允许</strong></p><p><img src="http://mdrs.yuanjin.tech/img/image-20200421152122793.png" alt="image-20200421152122793"></p><p>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p><p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p><p>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p><ul><li><strong>简单请求</strong></li><li><strong>需要预检的请求</strong></li><li><strong>附带身份凭证的请求</strong></li></ul><p>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。</p><p>下面分别说明三种请求模式的具体规范。</p><h2 id="简单请求" tabindex="-1">简单请求 <a class="header-anchor" href="#简单请求" aria-label="Permalink to &quot;简单请求&quot;">​</a></h2><p>当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式</p><h3 id="简单请求的判定" tabindex="-1">简单请求的判定 <a class="header-anchor" href="#简单请求的判定" aria-label="Permalink to &quot;简单请求的判定&quot;">​</a></h3><p>当请求<strong>同时满足</strong>以下条件时，浏览器会认为它是一个简单请求：</p><ol><li><p><strong>请求方法属于下面的一种：</strong></p><ul><li>get</li><li>post</li><li>head</li></ul></li><li><p><strong>请求头仅包含安全的字段，常见的安全字段如下：</strong></p><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul></li><li><p><strong>请求头如果包含<code>Content-Type</code>，仅限下面的值之一：</strong></p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ol><p>如果以上三个条件同时满足，浏览器判定为简单请求。</p><p>下面是一些例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/news&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 请求方法不满足要求，不是简单请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/news&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;PUT&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加入了额外的请求头，不是简单请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/news&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/news&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;post&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// content-type不满足要求，不是简单请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/news&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;post&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;content-type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/json&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="简单请求的交互规范" tabindex="-1">简单请求的交互规范 <a class="header-anchor" href="#简单请求的交互规范" aria-label="Permalink to &quot;简单请求的交互规范&quot;">​</a></h3><p>当浏览器判定某个<strong>ajax 跨域请求</strong>是<strong>简单请求</strong>时，会发生以下的事情</p><ol><li><strong>请求头中会自动添加<code>Origin</code>字段</strong></li></ol><p>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/news&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>请求发出后，请求头会是下面的格式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GET /api/news/ HTTP/1.1</span></span>
<span class="line"><span>Host: crossdomain.com</span></span>
<span class="line"><span>Connection: keep-alive</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Referer: http://my.com/index.html</span></span>
<span class="line"><span>Origin: http://my.com</span></span></code></pre></div><p>看到最后一行没，<code>Origin</code>字段会告诉服务器，是哪个源地址在跨域请求</p><ol start="2"><li><strong>服务器响应头中应包含<code>Access-Control-Allow-Origin</code></strong></li></ol><p>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加<code>Access-Control-Allow-Origin</code>字段</p><p>该字段的值可以是：</p><ul><li>*：表示我很开放，什么人我都允许访问</li><li>具体的源：比如<code>http://my.com</code>，表示我就允许你访问</li></ul><blockquote><p>实际上，这两个值对于客户端<code>http://my.com</code>而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</p><p>当然，服务器也可以维护一个可被允许的源列表，如果请求的<code>Origin</code>命中该列表，才响应<code>*</code>或具体的源</p><p><strong>为了避免后续的麻烦，强烈推荐响应具体的源</strong></p></blockquote><p>假设服务器做出了以下的响应：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Date: Tue, 21 Apr 2020 08:03:35 GMT</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Access-Control-Allow-Origin: http://my.com</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>消息体中的数据</span></span></code></pre></div><p>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作</p><p>下图简述了整个交互过程</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200421162846480.png" alt="image-20200421162846480"></p><h2 id="需要预检的请求" tabindex="-1">需要预检的请求 <a class="header-anchor" href="#需要预检的请求" aria-label="Permalink to &quot;需要预检的请求&quot;">​</a></h2><p>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。</p><p>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p><ol><li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li><li><strong>服务器允许</strong></li><li><strong>浏览器发送真实请求</strong></li><li><strong>服务器完成真实的响应</strong></li></ol><p>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要预检的请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crossdomain.com/api/user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;POST&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// post 请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置请求头</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;content-type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/json&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;袁小进&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置请求体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p><ol><li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>OPTIONS /api/user HTTP/1.1</span></span>
<span class="line"><span>Host: crossdomain.com</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Origin: http://my.com</span></span>
<span class="line"><span>Access-Control-Request-Method: POST</span></span>
<span class="line"><span>Access-Control-Request-Headers: a, b, content-type</span></span></code></pre></div><p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。</p><p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p><p>预检请求<strong>没有请求体</strong>，它包含了后续真实请求要做的事情</p><p>预检请求有以下特征：</p><ul><li>请求方法为<code>OPTIONS</code></li><li>没有请求体</li><li>请求头中包含 <ul><li><code>Origin</code>：请求的源，和简单请求的含义一致</li><li><code>Access-Control-Request-Method</code>：后续的真实请求将使用的请求方法</li><li><code>Access-Control-Request-Headers</code>：后续的真实请求会改动的请求头</li></ul></li></ul><ol start="2"><li><strong>服务器允许</strong></li></ol><p>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Date: Tue, 21 Apr 2020 08:03:35 GMT</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Access-Control-Allow-Origin: http://my.com</span></span>
<span class="line"><span>Access-Control-Allow-Methods: POST</span></span>
<span class="line"><span>Access-Control-Allow-Headers: a, b, content-type</span></span>
<span class="line"><span>Access-Control-Max-Age: 86400</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p><ul><li><code>Access-Control-Allow-Origin</code>：和简单请求一样，表示允许的源</li><li><code>Access-Control-Allow-Methods</code>：表示允许的后续真实的请求方法</li><li><code>Access-Control-Allow-Headers</code>：表示允许改动的请求头</li><li><code>Access-Control-Max-Age</code>：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li></ul><ol start="3"><li><strong>浏览器发送真实请求</strong></li></ol><p>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POST /api/user HTTP/1.1</span></span>
<span class="line"><span>Host: crossdomain.com</span></span>
<span class="line"><span>Connection: keep-alive</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Referer: http://my.com/index.html</span></span>
<span class="line"><span>Origin: http://my.com</span></span>
<span class="line"><span></span></span>
<span class="line"><span>{&quot;name&quot;: &quot;袁小进&quot;, &quot;age&quot;: 18 }</span></span></code></pre></div><ol start="4"><li><strong>服务器响应真实请求</strong></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Date: Tue, 21 Apr 2020 08:03:35 GMT</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Access-Control-Allow-Origin: http://my.com</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>添加用户成功</span></span></code></pre></div><p>可以看出，当完成预检之后，后续的处理与简单请求相同</p><p>下图简述了整个交互过程</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200421165913320.png" alt="image-20200421165913320"></p><h2 id="附带身份凭证的请求" tabindex="-1">附带身份凭证的请求 <a class="header-anchor" href="#附带身份凭证的请求" aria-label="Permalink to &quot;附带身份凭证的请求&quot;">​</a></h2><p>默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行</p><p>不过可以通过简单的配置就可以实现附带 cookie</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// xhr</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xhr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> XMLHttpRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.withCredentials </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fetch api</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  credentials: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;include&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这样一来，该跨域的 ajax 请求就是一个<em>附带身份凭证的请求</em></p><p>当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加<code>cookie</code>字段</p><p>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据</p><p>告知的方式也非常的简单，只需要在响应头中添加：<code>Access-Control-Allow-Credentials: true</code>即可</p><p>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。</p><p>另外要特别注意的是：<strong>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin 的值为*</code></strong>。这就是为什么不推荐使用*的原因</p><h2 id="一个额外的补充" tabindex="-1">一个额外的补充 <a class="header-anchor" href="#一个额外的补充" aria-label="Permalink to &quot;一个额外的补充&quot;">​</a></h2><p>在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Access-Control-Expose-Headers: authorization, a, b</span></span></code></pre></div><p>这样 JS 就能够访问指定的响应头了。</p><h1 id="jsonp" tabindex="-1">JSONP <a class="header-anchor" href="#jsonp" aria-label="Permalink to &quot;JSONP&quot;">​</a></h1><p>在CORS出现之前，人们想了一种奇妙的办法来实现跨域，这就是JSONP。</p><p>要实现JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。</p><p>JSONP的做法是：<strong>当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</strong></p><p><img src="http://mdrs.yuanjin.tech/img/20210916151516.png" alt="image-20210916151516184"></p><p>JSONP有着明显的缺点，即其只能支持GET请求</p><h1 id="文件上传的消息格式" tabindex="-1">文件上传的消息格式 <a class="header-anchor" href="#文件上传的消息格式" aria-label="Permalink to &quot;文件上传的消息格式&quot;">​</a></h1><p>文件上传的本质仍然是一个数据提交，无非就是数据量大一些而已</p><p>在实践中，人们逐渐的形成了一种共识，我们自行规定，文件上传默认使用下面的请求格式</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POST 上传地址 HTTP/1.1</span></span>
<span class="line"><span>其他请求头</span></span>
<span class="line"><span>Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span></span>
<span class="line"><span></span></span>
<span class="line"><span>----WebKitFormBoundary7MA4YWxkTrZu0gW</span></span>
<span class="line"><span>Content-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;小仙女.jpg&quot;</span></span>
<span class="line"><span>Content-Type: image/jpeg</span></span>
<span class="line"><span></span></span>
<span class="line"><span>(文件二进制数据)</span></span>
<span class="line"><span>----WebKitFormBoundary7MA4YWxkTrZu0gW</span></span>
<span class="line"><span>Content-Disposition: form-data; name=&quot;username&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>admin</span></span>
<span class="line"><span>----WebKitFormBoundary7MA4YWxkTrZu0gW</span></span>
<span class="line"><span>Content-Disposition: form-data; name=&quot;password&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>123123</span></span>
<span class="line"><span>----WebKitFormBoundary7MA4YWxkTrZu0gW</span></span></code></pre></div><ul><li>除非接口文档特别说明，文件上传一般使用POST请求</li><li>接口文档中会规定上传地址，一般一个站点会有一个统一的上传地址</li><li>除非接口文档特别说明，<code>content-type: multipart/form-data</code>，浏览器会自动分配一个定界符<code>boundary</code></li><li>请求体的格式是一个被定界符<code>boundary</code>分割的消息，每个分割区域本质就是一个键值对</li><li>除了键值对外，<code>multipart/form-data</code>允许添加其他额外信息，比如文件数据区域，一般会把文件在本地的名称和文件MIME类型告诉服务器</li></ul><h2 id="文件上传的实现" tabindex="-1">文件上传的实现 <a class="header-anchor" href="#文件上传的实现" aria-label="Permalink to &quot;文件上传的实现&quot;">​</a></h2><p>在现代的网页交互中，带表单的文件上传通常使用下面的方式实现</p><p><img src="http://mdrs.yuanjin.tech/img/20210917132919.png" alt="文件上传逻辑"></p><blockquote><p>后端开发服务器：<a href="http://localhost:8000" target="_blank" rel="noreferrer">http://localhost:8000</a></p></blockquote><h2 id="接口示例" tabindex="-1">接口示例 <a class="header-anchor" href="#接口示例" aria-label="Permalink to &quot;接口示例&quot;">​</a></h2><h3 id="统一上传接口" tabindex="-1">统一上传接口 <a class="header-anchor" href="#统一上传接口" aria-label="Permalink to &quot;统一上传接口&quot;">​</a></h3><p><strong>请求路径</strong>：/api/upload</p><p><strong>请求方法</strong>：POST</p><p><strong>字段名</strong>：file</p><p><strong>尺寸限制</strong>：1M</p><p><strong>支持的文件后缀</strong>：.jpg, .jpeg, .gif, .png, .bmp, .webp</p><p><strong>上传成功的响应</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:8000/upload/a32d18.jpg&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 访问路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>可能发生的失败响应</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">403</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;文件超过了限制&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">403</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;无效的文件类型&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="用户注册接口" tabindex="-1">用户注册接口 <a class="header-anchor" href="#用户注册接口" aria-label="Permalink to &quot;用户注册接口&quot;">​</a></h3><p><strong>请求路径</strong>：/api/user/reg</p><p><strong>请求方法</strong>：POST</p><p><strong>支持消息类型</strong>：</p><ol><li>x-www-form-urlencoded</li><li>json</li></ol><p><strong>字段</strong>：</p><table tabindex="0"><thead><tr><th>字段名</th><th>含义</th><th>是否必须</th></tr></thead><tbody><tr><td>username</td><td>账号</td><td>是</td></tr><tr><td>password</td><td>密码</td><td>是</td></tr><tr><td>avatar</td><td>头像</td><td>是</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>注册成功的响应</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    username</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;monica&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    avatar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:8000/upload/a234wq1.jpg&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？</span></span></code></pre></div><h1 id="面试题-4" tabindex="-1">面试题 <a class="header-anchor" href="#面试题-4" aria-label="Permalink to &quot;面试题&quot;">​</a></h1><p>在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？</p><blockquote><p>参考答案：</p><ol><li>浏览器自动补全协议、端口</li><li>浏览器自动完成url编码</li><li>浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求</li><li>通过DNS解析找到服务器的IP地址</li><li>浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立</li><li>若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2</li><li>浏览器决定要附带哪些cookie到请求头中</li><li>浏览器自动设置好请求头、协议版本、cookie，发出GET请求</li><li>服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。</li><li>浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。</li><li>浏览器根据响应状态码决定如何处理这一次响应</li><li>浏览器根据响应头中的Content-Type字段识别响应类型，如果是text/html，则对响应体的内容进行HTML解析，否则做其他处理</li><li>浏览器根据响应头的其他内容完成缓存、cookie的设置</li><li>浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源</li><li>解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint）</li><li>在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件</li></ol></blockquote><h1 id="文件下载" tabindex="-1">文件下载 <a class="header-anchor" href="#文件下载" aria-label="Permalink to &quot;文件下载&quot;">​</a></h1><h2 id="文件下载的消息格式" tabindex="-1">文件下载的消息格式 <a class="header-anchor" href="#文件下载的消息格式" aria-label="Permalink to &quot;文件下载的消息格式&quot;">​</a></h2><p>服务器只要在响应头中加入<code>Content-Disposition: attachment; filename=&quot;xxx&quot;</code>即可触发浏览器的下载功能</p><p>其中：</p><ul><li>attachment 表示附件，浏览器看到此字段，触发下载行为（不同的浏览器下载行为有所区别）</li><li>filename=&quot;xxx&quot;，这是告诉浏览器，保存文件时使用的默认文件名</li></ul><p>这部分操作是由服务器完成的，和前端开发无关</p><h2 id="启用迅雷下载" tabindex="-1">启用迅雷下载 <a class="header-anchor" href="#启用迅雷下载" aria-label="Permalink to &quot;启用迅雷下载&quot;">​</a></h2><p>用户可能安装了某些下载工具，这些下载工具在安装时，都会自动安装相应的浏览器插件，只要对下载地址稍作修改，就会触发浏览器使用插件进行下载，当然，不同插件的地址规则不同</p><p>比如，迅雷的下载地址规则为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>thunder://base64(AA地址ZZ)</span></span></code></pre></div><h2 id="示例服务器提供的下载地址" tabindex="-1">示例服务器提供的下载地址 <a class="header-anchor" href="#示例服务器提供的下载地址" aria-label="Permalink to &quot;示例服务器提供的下载地址&quot;">​</a></h2><p><a href="http://localhost:8000/download/Wallpaper1.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper1.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper2.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper2.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper3.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper3.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper4.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper4.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper5.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper5.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper6.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper6.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper7.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper7.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper8.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper8.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper9.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper9.jpg</a></p><p><a href="http://localhost:8000/download/Wallpaper10.jpg" target="_blank" rel="noreferrer">http://localhost:8000/download/Wallpaper10.jpg</a></p><h1 id="cookie-1" tabindex="-1">cookie <a class="header-anchor" href="#cookie-1" aria-label="Permalink to &quot;cookie&quot;">​</a></h1><h2 id="cookie-的缺陷" tabindex="-1">cookie 的缺陷 <a class="header-anchor" href="#cookie-的缺陷" aria-label="Permalink to &quot;cookie 的缺陷&quot;">​</a></h2><p>cookie 是保存在客户端的，虽然为服务器减少了很多压力，但某些情况下，会出现麻烦。</p><p>比如，验证码</p><p><img src="http://mdrs.yuanjin.tech/img/20210914160537.png" alt="image-20210914160537829"></p><p>如果这样做，客户端可以随便填写一个别人的手机号，然后从 cookie 中获取到验证码，从而绕开整个验证。</p><p>因此，有些敏感数据是万万不能发送给客户端的</p><p>那要如何实现这一流程呢？</p><p><img src="http://mdrs.yuanjin.tech/img/20210914161657.png" alt="image-20210914161657162"></p><p>可见，session 也是键值对，它保存在服务器端，通过 sessionid 和客户端关联</p><h2 id="面试题-5" tabindex="-1">面试题 <a class="header-anchor" href="#面试题-5" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><ol><li>cookie 和 session 的区别是什么？</li></ol><blockquote><p>参考答案：</p><ol><li>cookie 的数据保存在浏览器端；session 的数据保存在服务器</li><li>cookie 的存储空间有限；session 的存储空间不限</li><li>cookie 只能保存字符串；session 可以保存任何类型的数据</li><li>cookie 中的数据容易被获取；session 中的数据难以获取</li></ol></blockquote><ol start="2"><li>如何消除 session</li></ol><blockquote><p>参考答案：</p><ol><li><p>过期时间</p><p>当客户端长时间没有传递 sessionid 过来时，服务器可以在过期时间之后自动清除 session</p></li><li><p>客户端主动通知</p><p>可以使用 JS 监听客户端页面关闭或其他退出操作，然后通知服务器清除 session</p></li></ol></blockquote><h1 id="http缓存协议" tabindex="-1">HTTP缓存协议 <a class="header-anchor" href="#http缓存协议" aria-label="Permalink to &quot;HTTP缓存协议&quot;">​</a></h1><h2 id="缓存的基本原理" tabindex="-1">缓存的基本原理 <a class="header-anchor" href="#缓存的基本原理" aria-label="Permalink to &quot;缓存的基本原理&quot;">​</a></h2><p>在一个C/S结构中，最基本的缓存分为两种：</p><ul><li>客户端缓存</li><li>服务器缓存</li></ul><p><strong>本文仅讨论客户端缓存</strong></p><p>所谓<strong>客户端缓存</strong>，顾名思义，是将某一次的响应结果保存在客户端（比如浏览器）中，而后续的请求仅需要从缓存中读取即可，极大的降低了服务器的处理压力。</p><p>客户端缓存的原理如下：</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200430202446870.png" alt="image-20200430202446870"></p><blockquote><p>这只是一个简易的原理图，实际情况可能有差异</p></blockquote><p>这里就设计到一个缓存策略的问题，这些问题包括：</p><ul><li>哪些资源需要加入到缓存，哪些不需要？</li><li>缓存的时间是多久呢？</li><li>如果服务器的资源有改动，客户端如何更新缓存呢？</li><li>如果缓存过期了，可是服务器上的资源并没有发生变动，又该如何处理呢？</li><li>.......</li></ul><p>要回答这些问题，就必须要清楚<code>http</code>中关于缓存的协议</p><p>理解了http的缓存协议，自然就能回答上面的问题了。</p><h2 id="来自服务器的缓存指令" tabindex="-1">来自服务器的缓存指令 <a class="header-anchor" href="#来自服务器的缓存指令" aria-label="Permalink to &quot;来自服务器的缓存指令&quot;">​</a></h2><p>当客户端发出一个<code>get</code>请求到服务器，服务器可能有以下的内心活动：「你请求的这个资源，我很少会改动它，干脆你把它缓存起来吧，以后就不要来烦我了」</p><p>为了表达这个美好的愿望，服务器在<strong>响应头</strong>中加入了以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cache-Control: max-age=3600</span></span>
<span class="line"><span>ETag: W/&quot;121-171ca289ebf&quot;</span></span>
<span class="line"><span>Date: Thu, 30 Apr 2020 12:39:56 GMT</span></span>
<span class="line"><span>Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</span></span></code></pre></div><p>这个响应头表达了下面的信息：</p><ul><li><code>Cache-Control: max-age=3600</code>，我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）</li><li><code>ETag: W/&quot;121-171ca289ebf&quot;</code>，这个资源的编号是<code>W/&quot;121-171ca289ebf&quot;</code></li><li><code>Date: Thu, 30 Apr 2020 12:39:56 GMT</code>，我给你响应这个资源的服务器时间是格林威治时间<code>2020-04-30 12:39:56</code></li><li><code>Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</code>，这个资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code></li></ul><p>这个美好的缓存愿望，就这样通过响应头传递给客户端了</p><p>如果客户端是其他应用程序，可能并不会理会服务器的愿望，也就是说，可能根本不会缓存任何东西。</p><p>但是凑巧客户端是一个浏览器，它和服务器一直以来都是相亲相爱的小伙伴，当它看到服务器的这个响应头表达的美好愿望后，立即忙起来：</p><ul><li>浏览器把这次请求得到的响应体缓存到本地文件中</li><li>浏览器标记这次请求的请求方法和请求路径</li><li>浏览器标记这次缓存的时间是3600秒</li><li>浏览器记录服务器的响应时间是格林威治时间<code>2020-04-30 12:39:56</code></li><li>浏览器记录服务器给予的资源编号<code>W/&quot;121-171ca289ebf&quot;</code></li><li>浏览器记录资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code></li></ul><p>这一次的记录非常重要，它为以后浏览器要不要去请求服务器提供了各种依据。</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200430210430455.png" alt="image-20200430210430455"></p><h2 id="来自客户端的缓存指令" tabindex="-1">来自客户端的缓存指令 <a class="header-anchor" href="#来自客户端的缓存指令" aria-label="Permalink to &quot;来自客户端的缓存指令&quot;">​</a></h2><p>当客户端收拾好行李，准备再次请求<code>GET /index.js</code>时，它突然想起了一件事：我需要的东西在不在缓存里呢？</p><p>此时，客户端会到缓存中去寻找是否有缓存的资源</p><p>寻找的过程如下：</p><ol><li>缓存中是否有匹配的请求方法和路径？</li><li>如果有，该缓存资源是否还有效呢？</li></ol><p>以上两个验证会导致浏览器产生不同的行为</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200430212052228.png" alt="image-20200430212052228"><img src="http://mdrs.yuanjin.tech/img/image-20200430214301507.png" alt="image-20200430214301507"></p><p>要验证是否有匹配的缓存非常简单，只需要验证当前的请求方法<code>GET</code>和当前的请求路径<code>/index.js</code>是否有对应的缓存存在即可</p><p>如果没有，就直接请求服务器，就和第一次请求服务器时一样，这种情况没有什么好讨论的</p><p>关键在于验证缓存是否有效</p><p>如何验证呢？</p><p>非常简单，就是把<code>max-age + Date</code>，得到一个过期时间，看看这个过期时间是否大于当前时间，如果是，则表示缓存还没有过期，仍然有效，如果不是，则表示缓存失效。</p><h3 id="缓存有效" tabindex="-1">缓存有效 <a class="header-anchor" href="#缓存有效" aria-label="Permalink to &quot;缓存有效&quot;">​</a></h3><p>当浏览器发现缓存有效时，完全不会请求服务器，直接使用缓存即可得到结果</p><p>此时，如果你断开网络，会发现资源仍然可用</p><p>这种情况会极大的降低服务器压力，但当服务器更改了资源后，浏览器是不知道的，只要缓存有效，它就会直接使用缓存</p><h3 id="缓存无效" tabindex="-1">缓存无效 <a class="header-anchor" href="#缓存无效" aria-label="Permalink to &quot;缓存无效&quot;">​</a></h3><p>当浏览器发现缓存已经过期，它<strong>并不会简单的把缓存删除</strong>，而是抱着一丝希望，想问问服务器，我<strong>这个缓存还能继续使用吗</strong>？</p><p>于是，浏览器向服务器发出了一个<strong>带缓存的请求</strong>，又称之为<strong>协商缓存</strong></p><p>所谓带缓存的请求，无非就是加入了以下的请求头：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT</span></span>
<span class="line"><span>If-None-Match: W/&quot;121-171ca289ebf&quot;</span></span></code></pre></div><p>它们表达了下面的信息：</p><ul><li><code>If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT</code>，亲，你曾经告诉我，这个资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code>，请问这个资源在这个时间之后有发生变动吗？</li><li><code>If-None-Match: W/&quot;121-171ca289ebf&quot;</code>，亲，你曾经告诉我，这个资源的编号是<code>W/&quot;121-171ca289ebf</code>，请问这个资源的编号发生变动了吗？</li></ul><p>其实，这两个问题可以合并为一个问题：快说！资源到底变了没有！</p><p>之所以要发两个信息，是为了兼容不同的服务器，因为有些服务器只认<code>If-Modified-Since</code>，有些服务器只认<code>If-None-Match</code>，有些服务器两个都认</p><blockquote><p>目前的很多服务器，只要发现<code>If-None-Match</code>存在，就不会去看\`\`If-Modified-Since\`</p><p><code>If-Modified-Since</code>是<code>http1.0</code>版本的规范，<code>If-None-Match</code>是<code>http1.1</code>的规范</p></blockquote><p>此时，问题又抛给了服务器，接下来，就是服务器的表演时间了</p><p>服务器可能会产生两个情况：</p><ul><li>缓存已经失效</li><li>缓存仍然有效</li></ul><p>如果是第一种情况——<strong>缓存已经失效</strong>，那么非常简单，服务器再次给予一个正常的响应（响应码<code>200</code> 带响应体），同时可以附带上新的缓存指令，这就回到了上一节——来自服务器的缓存指令</p><p>这样一来，客户端就会重新缓存新的内容</p><p>但如果服务器觉得<strong>缓存仍然有效</strong>，它可以通过一种极其简单的方式告诉客户端：</p><ul><li>响应码为<code>304 Not Modified</code></li><li>无响应体</li><li>响应头带上新的缓存指令，见上一节——来自服务器的缓存指令</li></ul><p>这样一来，就相当于告诉客户端：「你的缓存资源仍然可用，我给你一个新的缓存时间，你那边更新一下就可以了」</p><p>于是，客户端就继续happy的使用缓存了</p><p>这样一来，可以最大程度的减少网络传输，因为如果资源还有效，服务器就不会传输消息体</p><p>它们完整的交互过程如下：</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200430225326001.png" alt="image-20200430225326001"></p><h2 id="细节" tabindex="-1">细节 <a class="header-anchor" href="#细节" aria-label="Permalink to &quot;细节&quot;">​</a></h2><p>上面描述了客户端缓存的基本概念和过程</p><p>但其中仍然有不少细节值得我们注意</p><h3 id="cache-control" tabindex="-1">Cache-Control <a class="header-anchor" href="#cache-control" aria-label="Permalink to &quot;Cache-Control&quot;">​</a></h3><p>在上述的讲解中，<code>Cache-Control</code>是服务器向客户端响应的一个消息头，它提供了一个<code>max-age</code>用于指定缓存时间。</p><p>实际上，<code>Cache-Control</code>还可以设置下面一个或多个值：</p><ul><li><code>public</code>：指示服务器资源是公开的。比如有一个页面资源，所有人看到的都是一样的。这个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原则，<code>http</code>协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，完全看它自己。</li><li><code>private</code>：指示服务器资源是私有的。比如有一个页面资源，每个用户看到的都不一样。这个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原则，<code>http</code>协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，完全看它自己。</li><li><code>no-cache</code>：告知客户端，你可以缓存这个资源，但是不要<strong>直接</strong>使用它。当你缓存之后，后续的每一次请求都需要附带缓存指令，让服务器告诉你这个资源有没有过期。见：「来自客户端的缓存指令 - 缓存无效」</li><li><code>no-store</code>：告知客户端，不要对这个资源做任何的缓存，之后的每一次请求都按照正常的普通请求进行。若设置了这个值，浏览器将不会对该资源做出任何的缓存处理。</li><li><code>max-age</code>：不再赘述</li></ul><p>比如，<code>Cache-Control: public, max-age=3600</code>表示这是一个公开资源，请缓存1个小时。</p><h3 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-label="Permalink to &quot;Expires&quot;">​</a></h3><p>在<code>http1.0</code>版本中，是通过<code>Expires</code>响应头来指定过期时间点的，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Expires: Thu, 30 Apr 2020 23:38:38 GMT</span></span></code></pre></div><p>到了<code>http1.1</code>版本，已更改为通过<code>Cache-Control</code>的<code>max-age</code>来记录了。</p><h3 id="记录缓存时的有效期" tabindex="-1">记录缓存时的有效期 <a class="header-anchor" href="#记录缓存时的有效期" aria-label="Permalink to &quot;记录缓存时的有效期&quot;">​</a></h3><p>浏览器会按照服务器响应头的要求，自动记录缓存到本地文件，并设置各种相关信息</p><p>在这些信息中，<strong>有效期</strong>尤为关键，它决定了这个缓存可以使用多久</p><p>浏览器会根据服务器不同的响应情况，设置不同的有效期</p><p>具体的有效期设置，按照下面的流程进行：</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200501075337464.png" alt="image-20200501075337464"></p><p>例如，当<code>max-age</code>设置为0时，缓存立即过期</p><p>虽然立即过期，但缓存仍然被记录下来，后续的请求通过缓存指令发送到服务器，来确认资源是否被更改。</p><p>因此，<code>Cache-Control: max-age=0</code>类似于<code>Cache-Control: no-cache</code></p><h3 id="pragma" tabindex="-1">Pragma <a class="header-anchor" href="#pragma" aria-label="Permalink to &quot;Pragma&quot;">​</a></h3><p>这是<code>http1.0</code>版本的消息头</p><p>当该消息头出现在请求中时，是向服务器表达：不要考虑任何缓存，给我一个正常的结果。</p><p>在<code>http1.1</code>版本中，可以在<strong>请求头</strong>中加入<code>Cache-Control: no-cache</code>实现同样的含义。</p><blockquote><p>是的，<code>Cache-Control</code>可以出现在请求头中</p></blockquote><p>在<code>Chrome</code>浏览器中调试时，如果勾选了<code>Disable cache</code>，则发送的请求中会附带该信息</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200501080330131.png" alt="image-20200501080330131"></p><h3 id="vary" tabindex="-1">Vary <a class="header-anchor" href="#vary" aria-label="Permalink to &quot;Vary&quot;">​</a></h3><p>有的时候，是否有缓存，不仅仅是判断请求方法和请求路径是否匹配，可能还要判断头部信息是否匹配。</p><p>此时，就可以使用<code>Vary</code>字段来指定要区分的消息头</p><p>比如，当使用<code>GET /personal.html</code>请求服务器时，请求头中<code>cookie</code>的值不一样，得到的页面也不一样</p><p>如果还按照之前的做法，仅仅匹配请求方法和请求路径，如果<code>cookie</code>变动，你可能得到的仍然是之前的页面。</p><p>正确的做法如下：</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200501082103089.png" alt="image-20200501082103089"></p><h3 id="使用版本号或hash" tabindex="-1">使用版本号或hash <a class="header-anchor" href="#使用版本号或hash" aria-label="Permalink to &quot;使用版本号或hash&quot;">​</a></h3><p>如果你是一个前端工程师，使用过<code>vue</code>或其他基于<code>webpack</code>搭建的工程</p><p>你会发现打包的结果中很多文件名类似于这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>app.68297cd8.css</span></span></code></pre></div><p>文件的中间部分使用了<code>hash</code>值</p><p>这样做的好处是，可以让客户端大胆的、长时间的缓存该文件，减轻服务器的压力</p><p>当文件改动后，它的文件<code>hash</code>值也会随之而变，比如变成了<code>app.446fccb8.css</code></p><p>这样一来，客户端要请求新的文件时，就会发现路径从<code>/app.68297cd8.css</code>变成了<code>app.446fccb8.css</code>，由于之前的缓存路径无法匹配到，因此就会发送新的请求来获取新资源了。</p><p>以上是现代流行的做法。</p><p>而在古老的年代，还没有构建工具出现时，人们使用的办法是在资源路径后面加入版本号来获取新版本的文件</p><p>比如，页面中引入了一个css资源<code>app.css</code>，它可能的引入方式是：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app.css?v=1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这样一来，缓存的路径是<code>/app.css?v=1.0.0</code></p><p>当服务器的版本发生变化时，可以给予新的版本号，让html中的路径发生变动</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app.css?v=1.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>由于新的路径无法命中缓存，于是浏览器就会发送新的普通请求来获取这个资源</p><h1 id="总结-2" tabindex="-1">总结 <a class="header-anchor" href="#总结-2" aria-label="Permalink to &quot;总结&quot;">​</a></h1><p>最后，通过客户端和服务器两位大佬的视角，来总结一下以上内容</p><h3 id="服务器视角" tabindex="-1">服务器视角 <a class="header-anchor" href="#服务器视角" aria-label="Permalink to &quot;服务器视角&quot;">​</a></h3><p>服务器无法知道客户端到底有没有像浏览器那样缓存文件，它只管根据请求的情况来决定如何响应</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200501083702987.png" alt="image-20200501083702987"></p><p>很多后端语言搭建的服务器都会自带自己的默认缓存规则，当然也支持不同程度的修改</p><h3 id="浏览器视角" tabindex="-1">浏览器视角 <a class="header-anchor" href="#浏览器视角" aria-label="Permalink to &quot;浏览器视角&quot;">​</a></h3><p>浏览器在发出请求时会判断要不要使用缓存</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200501084258712.png" alt="image-20200501084258712"></p><p>当收到服务器响应时，会自动根据缓存指令进行处理</p><p><img src="http://mdrs.yuanjin.tech/img/image-20200501084559394.png" alt="image-20200501084559394"></p>`,512)])])}const g=a(n,[["render",t]]);export{k as __pageData,g as default};
